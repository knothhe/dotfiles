#!/usr/bin/env python3
"""
x_sharding - Database Table Sharding Tool

Transforms single-table CREATE TABLE statements into sharded database
table definitions based on specified sharding rules.
"""

import argparse
import re
import os
import sys
from pathlib import Path
from typing import List, Dict, Tuple, Optional


class ColorFormatter:
    """Color formatting class for rich terminal output."""

    # ANSI color codes
    COLORS = {
        'NC': '\033[0m',      # No Color
        'RED': '\033[0;31m',
        'GREEN': '\033[0;32m',
        'YELLOW': '\033[0;33m',
        'BLUE': '\033[0;34m',
        'MAGENTA': '\033[0;35m',
        'CYAN': '\033[0;36m',
        'WHITE': '\033[0;37m',
        'BOLD': '\033[1m',
        'RED_BOLD': '\033[1;31m',
        'GREEN_BOLD': '\033[1;32m',
        'YELLOW_BOLD': '\033[1;33m',
        'BLUE_BOLD': '\033[1;34m',
        'MAGENTA_BOLD': '\033[1;35m',
        'CYAN_BOLD': '\033[1;36m',
        'WHITE_BOLD': '\033[1;37m',
    }

    @classmethod
    def format_text(cls, text: str, color: str = 'NC') -> str:
        """Format text with specified color."""
        return f"{cls.COLORS.get(color, '')}{text}{cls.COLORS['NC']}"

    @classmethod
    def print_title(cls, title: str):
        """Print a formatted title with borders."""
        border = "=" * 60
        print(f"\n{cls.COLORS['CYAN_BOLD']}{border}{cls.COLORS['NC']}")
        print(f"{cls.COLORS['CYAN_BOLD']}  {title.center(56)}{cls.COLORS['NC']}")
        print(f"{cls.COLORS['CYAN_BOLD']}{border}{cls.COLORS['NC']}\n")

    @classmethod
    def print_header(cls, text: str):
        """Print a colored header."""
        print(f"\n{cls.COLORS['BLUE_BOLD']}{text}{cls.COLORS['NC']}")

    @classmethod
    def print_success(cls, text: str):
        """Print success message in green."""
        print(f"{cls.COLORS['GREEN']}âœ“ {text}{cls.COLORS['NC']}")

    @classmethod
    def print_success_bold(cls, text: str):
        """Print bold success message."""
        print(f"{cls.COLORS['GREEN_BOLD']}âœ“ {text}{cls.COLORS['NC']}")

    @classmethod
    def print_error(cls, text: str):
        """Print error message in red."""
        print(f"{cls.COLORS['RED']}âœ— {text}{cls.COLORS['NC']}", file=sys.stderr)

    @classmethod
    def print_warning(cls, text: str):
        """Print warning message in yellow."""
        print(f"{cls.COLORS['YELLOW']}âš  {text}{cls.COLORS['NC']}")

    @classmethod
    def print_info(cls, text: str):
        """Print info message in blue."""
        print(f"{cls.COLORS['BLUE']}â„¹ {text}{cls.COLORS['NC']}")

    @classmethod
    def print_highlight(cls, text: str, color: str = 'CYAN'):
        """Print highlighted text."""
        print(f"{cls.COLORS.get(f'{color}_BOLD', cls.COLORS['BOLD'])}{text}{cls.COLORS['NC']}")

    @classmethod
    def print_progress(cls, text: str):
        """Print progress message in cyan."""
        print(f"{cls.COLORS['CYAN']}âŸ³ {text}{cls.COLORS['NC']}")

    @classmethod
    def print_completion(cls, text: str):
        """Print completion message with decorations."""
        print(f"\n{cls.COLORS['GREEN_BOLD']}ðŸŽ‰ {text}{cls.COLORS['NC']}")

    @classmethod
    def print_table_item(cls, item: str, indent: int = 2):
        """Print table list item with proper indentation."""
        spaces = " " * indent
        print(f"{spaces}{cls.COLORS['CYAN']}â€¢{cls.COLORS['NC']} {item}")

    @classmethod
    def print_stat(cls, label: str, value: str, value_color: str = 'YELLOW_BOLD'):
        """Print a statistic with colored value."""
        print(f"  {cls.COLORS['WHITE']}{label}:{cls.COLORS['NC']} {cls.COLORS[value_color]}{value}{cls.COLORS['NC']}")

    @classmethod
    def print_config_summary(cls, config: dict):
        """Print configuration summary in a formatted box."""
        print(f"\n{cls.COLORS['CYAN_BOLD']}" + "="*60 + f"{cls.COLORS['NC']}")
        print(f"{cls.COLORS['CYAN_BOLD']}  {'CONFIGURATION SUMMARY'.center(56)}{cls.COLORS['NC']}")
        print(f"{cls.COLORS['CYAN_BOLD']}" + "="*60 + f"{cls.COLORS['NC']}")

        # Group configurations by category
        if config.get('mode'):
            print(f"\n{cls.COLORS['BLUE_BOLD']}Mode:{cls.COLORS['NC']}")
            cls.print_stat("Type", config['mode'], 'GREEN_BOLD')

        if config.get('input_file'):
            print(f"\n{cls.COLORS['BLUE_BOLD']}Files:{cls.COLORS['NC']}")
            cls.print_stat("Input", config['input_file'], 'YELLOW_BOLD')
            if config.get('output_file'):
                cls.print_stat("Output", config['output_file'], 'YELLOW_BOLD')

        if config.get('db_count') is not None:
            print(f"\n{cls.COLORS['BLUE_BOLD']}Database Configuration:{cls.COLORS['NC']}")
            cls.print_stat("Database Count", str(config['db_count']), 'GREEN_BOLD')
            if config.get('db_name_prefix'):
                cls.print_stat("Database Prefix", config['db_name_prefix'], 'YELLOW_BOLD')
        else:
            print(f"\n{cls.COLORS['BLUE_BOLD']}Database Configuration:{cls.COLORS['NC']}")
            cls.print_stat("Type", "Single Database", 'GREEN_BOLD')

        if config.get('table_stats'):
            print(f"\n{cls.COLORS['BLUE_BOLD']}Table Configuration:{cls.COLORS['NC']}")
            for stat in config['table_stats']:
                cls.print_stat(stat['label'], stat['value'], stat.get('color', 'YELLOW_BOLD'))

        if config.get('options'):
            print(f"\n{cls.COLORS['BLUE_BOLD']}Options:{cls.COLORS['NC']}")
            for option in config['options']:
                if option['enabled']:
                    cls.print_stat(option['name'], "Enabled", 'GREEN_BOLD')
                else:
                    cls.print_stat(option['name'], "Disabled", 'YELLOW')

        print(f"\n{cls.COLORS['CYAN_BOLD']}" + "="*60 + f"{cls.COLORS['NC']}\n")


class TableDefinition:
    """Represents a parsed CREATE TABLE statement with associated statements."""

    def __init__(self, name: str, full_statement: str):
        self.name = name
        self.full_statement = full_statement
        self.drop_statement = None  # DROP TABLE IF EXISTS statement
        self.index_statements = []  # CREATE INDEX statements


class SQLParser:
    """Parser for SQL CREATE TABLE statements."""

    # Regex pattern to match CREATE TABLE statements
    CREATE_TABLE_PATTERN = re.compile(
        r'CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?`?([^`\s]+)`?\s*\((.*?)\)\s*[^;]*',
        re.IGNORECASE | re.DOTALL
    )

    # Regex pattern to match DROP TABLE IF EXISTS statements
    DROP_TABLE_PATTERN = re.compile(
        r'DROP\s+TABLE\s+IF\s+EXISTS\s+`?([^\s;]+)`?[^;]*',
        re.IGNORECASE
    )

    # Regex pattern to match CREATE INDEX statements
    CREATE_INDEX_PATTERN = re.compile(
        r'CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?`?([^`\s]+)`?\s+ON\s+`?([^\s;]+)`?\s*\(([^)]+)\)[^;]*',
        re.IGNORECASE
    )

    @staticmethod
    def parse_sql_file(file_path: str) -> List[TableDefinition]:
        """Parse SQL file and extract CREATE TABLE statements with associated statements."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Input file not found: {file_path}")
        except Exception as e:
            raise Exception(f"Error reading input file: {e}")

        tables = []
        table_dict = {}  # Dictionary to track tables by name for association

        # First pass: Find all CREATE TABLE statements
        for match in SQLParser.CREATE_TABLE_PATTERN.finditer(content):
            table_name = match.group(1)
            full_statement = match.group(0)
            table = TableDefinition(table_name, full_statement)
            tables.append(table)
            table_dict[table_name] = table

        # Second pass: Find and associate DROP TABLE statements
        for match in SQLParser.DROP_TABLE_PATTERN.finditer(content):
            table_name = match.group(1)
            drop_statement = match.group(0)
            if table_name in table_dict:
                table_dict[table_name].drop_statement = drop_statement

        # Third pass: Find and associate CREATE INDEX statements
        for match in SQLParser.CREATE_INDEX_PATTERN.finditer(content):
            index_name = match.group(1)
            table_name = match.group(2)
            index_columns = match.group(3)
            full_statement = match.group(0)

            if table_name in table_dict:
                table_dict[table_name].index_statements.append(full_statement)

        return tables


class ShardingGenerator:
    """Generates sharded SQL statements from parsed tables."""

    def __init__(self, db_count: Optional[int], table_count: int, selected_tables: Optional[List[str]] = None,
                 reset_per_db: bool = False, pad_zero: bool = False):
        self.db_count = db_count
        self.table_count = table_count
        self.selected_tables = selected_tables
        self.reset_per_db = reset_per_db
        self.pad_zero = pad_zero

    def filter_tables(self, tables: List[TableDefinition]) -> List[TableDefinition]:
        """Filter tables based on selected_tables list."""
        if not self.selected_tables:
            return tables

        filtered = []
        selected_set = set(self.selected_tables)

        for table in tables:
            if table.name in selected_set:
                filtered.append(table)
            else:
                ColorFormatter.print_warning(f"Table '{table.name}' skipped (not in selected tables)")

        # Check for tables that were specified but not found
        found_tables = {table.name for table in filtered}
        missing_tables = selected_set - found_tables
        if missing_tables:
            ColorFormatter.print_warning(f"Specified tables not found in input: {', '.join(missing_tables)}")

        return filtered

    def pad_number(self, number: int, max_number: int) -> str:
        """Add zero-padding to numbers if pad_zero is enabled."""
        if not self.pad_zero:
            return str(number)

        # Calculate required padding based on max number
        padding = len(str(max_number))
        return str(number).zfill(padding)

    def generate_table_name(self, original_name: str, table_suffix: int) -> str:
        """Generate sharded table name with suffix."""
        padded_suffix = self.pad_number(table_suffix, self.table_count)
        return f"{original_name}_{padded_suffix}"

    def generate_sharded_sql(self, tables: List[TableDefinition], db_name_prefix: str = "db") -> str:
        """Generate complete sharded SQL statements."""
        if not tables:
            raise ValueError("No tables to shard after filtering")

        sql_lines = []

        # Single database mode (no db_count specified)
        if self.db_count is None:
            total_shards = self.table_count * len(tables)
            print(f"Creating {total_shards} tables ({len(tables)} tables Ã— {self.table_count} shards each)")

            # Generate shards for each table
            for original_table in tables:

                for table_suffix in range(self.table_count):
                    # Generate sharded table name
                    sharded_table_name = self.generate_table_name(original_table.name, table_suffix)

                    # Add DROP TABLE IF EXISTS statement if exists
                    if original_table.drop_statement:
                        sharded_drop = self._replace_drop_table_name(original_table.drop_statement, sharded_table_name)
                        sql_lines.append(sharded_drop + ";")

                    # Replace original table name with sharded name in CREATE TABLE statement
                    sharded_statement = self._replace_table_name(original_table.full_statement, sharded_table_name)
                    sql_lines.append(sharded_statement + ";")

                    # Add CREATE INDEX statements if any
                    for index_statement in original_table.index_statements:
                        # Extract index name from the statement
                        index_match = re.match(r'CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?`?([^`\s]+)`?', index_statement, re.IGNORECASE)
                        if index_match:
                            original_index_name = index_match.group(1)
                            sharded_index_name = self._generate_index_name(original_index_name, original_table.name, table_suffix)
                            sharded_index = self._replace_index_table_name(index_statement, sharded_table_name, sharded_index_name)
                            sql_lines.append(sharded_index + ";")

                    sql_lines.append("")

            return "\n".join(sql_lines)

        # Multi-database mode - each table gets self.table_count shards in each database
        total_shards = self.db_count * self.table_count * len(tables)
        print(f"Creating {total_shards} tables in {self.db_count} databases")

        for db_index in range(1, self.db_count + 1):
            db_name = f"{db_name_prefix}{self.pad_number(db_index - 1, self.db_count)}"

            # Add database creation statement
            sql_lines.append(f"-- Sharded database: {db_name}")
            sql_lines.append(f"CREATE DATABASE IF NOT EXISTS `{db_name}` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;")
            sql_lines.append(f"USE `{db_name}`;")
            sql_lines.append("")

            # Generate shards for each table in this database
            for original_table in tables:

                for table_suffix in range(self.table_count):
                    # Generate sharded table name
                    sharded_table_name = self.generate_table_name(original_table.name, table_suffix)

                    # Add DROP TABLE IF EXISTS statement if exists
                    if original_table.drop_statement:
                        sharded_drop = self._replace_drop_table_name(original_table.drop_statement, sharded_table_name)
                        sql_lines.append(sharded_drop + ";")

                    # Replace original table name with sharded name in CREATE TABLE statement
                    sharded_statement = self._replace_table_name(original_table.full_statement, sharded_table_name)
                    sql_lines.append(sharded_statement + ";")

                    # Add CREATE INDEX statements if any
                    for index_statement in original_table.index_statements:
                        # Extract index name from the statement
                        index_match = re.match(r'CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?`?([^`\s]+)`?', index_statement, re.IGNORECASE)
                        if index_match:
                            original_index_name = index_match.group(1)
                            sharded_index_name = self._generate_index_name(original_index_name, original_table.name, table_suffix)
                            sharded_index = self._replace_index_table_name(index_statement, sharded_table_name, sharded_index_name)
                            sql_lines.append(sharded_index + ";")

                    sql_lines.append("")

            # Add separator between databases
            if db_index < self.db_count:
                sql_lines.append("")
                sql_lines.append("")

        return "\n".join(sql_lines)

    def _replace_table_name(self, original_statement: str, new_name: str) -> str:
        """Replace table name in CREATE TABLE statement."""
        # Replace the table name in CREATE TABLE line
        pattern = r'(CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?`?)[^`\s]+(`?\s*\()'
        replacement = f'\\g<1>{new_name}\\g<2>'
        return re.sub(pattern, replacement, original_statement, flags=re.IGNORECASE)

    def _replace_drop_table_name(self, drop_statement: str, new_name: str) -> str:
        """Replace table name in DROP TABLE statement."""
        # Replace the table name in DROP TABLE line
        pattern = r'(DROP\s+TABLE\s+IF\s+EXISTS\s+`?)[^`\s;]+`?'
        replacement = f'\\g<1>{new_name}'
        return re.sub(pattern, replacement, drop_statement, flags=re.IGNORECASE)

    def _replace_index_table_name(self, index_statement: str, new_table_name: str, new_index_name: str) -> str:
        """Replace table name and index name in CREATE INDEX statement."""
        # Replace the table name in CREATE INDEX line
        pattern = r'(CREATE\s+(?:UNIQUE\s+)?INDEX\s+(?:IF\s+NOT\s+EXISTS\s+)?`?)[^`\s]+`?\s+ON\s+`?[^`\s;]+`?(\s*\([^)]+\))'
        replacement = f'\\g<1>{new_index_name} ON `{new_table_name}`\\g<2>'
        return re.sub(pattern, replacement, index_statement, flags=re.IGNORECASE)

    def _generate_index_name(self, original_index_name: str, table_name: str, table_suffix: int) -> str:
        """Generate sharded index name."""
        # If index name contains table name, replace it with sharded table name
        if table_name.lower() in original_index_name.lower():
            sharded_table_name = self.generate_table_name(table_name, table_suffix)
            return original_index_name.replace(table_name, sharded_table_name)
        else:
            # Append suffix to index name
            return f"{original_index_name}_{self.pad_number(table_suffix, self.table_count)}"


def validate_arguments(args: argparse.Namespace) -> None:
    """Validate command line arguments."""
    if args.db_count is not None and args.db_count <= 0:
        raise ValueError("Database count must be positive")

    if args.table_count <= 0:
        raise ValueError("Table count must be positive")

    if args.db_count is not None and args.table_count < args.db_count:
        raise ValueError("Table count must be >= database count")

    if args.db_count is not None and not args.db_name:
        raise ValueError("Database name prefix (--db-name) is required when --db-count is specified")

    if not os.path.exists(args.input):
        raise FileNotFoundError(f"Input file does not exist: {args.input}")

    if not os.path.isfile(args.input):
        raise ValueError(f"Input path is not a file: {args.input}")


def check_output_file_exists(output_file: Path) -> bool:
    """Check if output file exists and has content."""
    if not output_file.exists():
        return False

    return output_file.stat().st_size > 0


def prompt_overwrite(output_file: Path) -> bool:
    """Prompt user for overwrite confirmation."""
    while True:
        response = input(f"Output file '{output_file}' already exists. Overwrite? [y/N]: ").strip().lower()
        if response in ['y', 'yes']:
            return True
        elif response in ['n', 'no', '']:
            return False
        else:
            ColorFormatter.print_warning("Please enter 'y' (yes) or 'n' (no)")


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate sharded database tables from CREATE TABLE statements",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Single database mode (only table sharding)
  x_sharding --input schema.sql --table-count 8

  # Multiple databases mode
  x_sharding --input schema.sql --db-count 4 --table-count 16 --db-name shard

  # Select specific tables only
  x_sharding --input schema.sql --db-count 3 --table-count 12 --db-name shard --tables "user,order"

  # Reset table numbering per database with zero-padding
  x_sharding --input schema.sql --db-count 2 --table-count 8 --db-name shard --reset-per-db --pad-zero

  # Custom output file
  x_sharding --input db_schema.sql --db-count 2 --table-count 8 --db-name shard --output production_shards.sql

  # Force overwrite existing output file
  x_sharding --input schema.sql --table-count 4 --force
        """
    )

    parser.add_argument(
        '--input', '-i',
        required=True,
        help='Input SQL file containing CREATE TABLE statements'
    )

    parser.add_argument(
        '--table-count', '-t',
        type=int,
        required=True,
        help='Total number of tables to generate'
    )

    parser.add_argument(
        '--db-count', '-d',
        type=int,
        help='Number of databases to create (optional, single database mode if not specified)'
    )

    parser.add_argument(
        '--db-name', '-n',
        help='Database name prefix (required when --db-count is specified)'
    )

    parser.add_argument(
        '--tables', '-s',
        help='Comma-separated list of table names to shard (optional, shard all tables if not specified)'
    )

    parser.add_argument(
        '--reset-per-db', '-r',
        action='store_true',
        help='Reset table numbering for each database (default: continue sequential numbering)'
    )

    parser.add_argument(
        '--pad-zero', '-p',
        action='store_true',
        help='Add zero-padding to table names for consistent sorting'
    )

    parser.add_argument(
        '--output', '-o',
        help='Output SQL file path (default: {input}_sharding.sql)'
    )

    parser.add_argument(
        '--force', '-f',
        action='store_true',
        help='Force overwrite output file if it exists (default: prompt for confirmation)'
    )

    return parser.parse_args()


def main():
    """Main entry point."""
    try:
        args = parse_arguments()
        validate_arguments(args)

        # Parse selected tables if specified
        selected_tables = None
        if args.tables:
            selected_tables = [table.strip() for table in args.tables.split(',') if table.strip()]
            if not selected_tables:
                raise ValueError("Invalid table list specified")

        # Generate output filename if not specified
        if args.output:
            output_file = Path(args.output)
        else:
            input_path = Path(args.input)
            output_file = input_path.parent / f"{input_path.stem}_sharding.sql"

        # Parse SQL file
        parser = SQLParser()
        tables = parser.parse_sql_file(args.input)

        if not tables:
            ColorFormatter.print_error("No CREATE TABLE statements found in input file")
            sys.exit(1)

        print(f"Found {len(tables)} tables")

        # Filter tables if specified
        if selected_tables:
            print(f"Filtering to: {', '.join(selected_tables)}")

        # Determine mode and database name prefix
        if args.db_count is not None:
            print(f"Mode: Multi-database ({args.db_count} databases)")
            db_name_prefix = args.db_name or "db"
        else:
            print(f"Mode: Single database (table sharding)")
            db_name_prefix = None

        # Generate sharded SQL
        generator = ShardingGenerator(
            db_count=args.db_count,
            table_count=args.table_count,
            selected_tables=selected_tables,
            reset_per_db=args.reset_per_db,
            pad_zero=args.pad_zero
        )

        filtered_tables = generator.filter_tables(tables)
        if not filtered_tables:
            ColorFormatter.print_error("No tables to shard after filtering")
            sys.exit(1)

        if selected_tables and len(filtered_tables) != len(selected_tables):
            actual_tables = [t.name for t in filtered_tables]
            missing = set(selected_tables) - set(actual_tables)
            if missing:
                ColorFormatter.print_warning(f"Specified tables not found: {', '.join(missing)}")

        # Display configuration summary before generating output
        total_shards = args.table_count * len(filtered_tables)
        if args.db_count is not None:
            total_shards = args.db_count * args.table_count * len(filtered_tables)

        config_summary = {
            'mode': f"Multi-database ({args.db_count} databases)" if args.db_count is not None else "Single database (table sharding)",
            'input_file': args.input,
            'output_file': str(output_file),
            'db_count': args.db_count,
            'db_name_prefix': db_name_prefix,
            'table_stats': [
                {'label': 'Original Tables', 'value': str(len(tables)), 'color': 'GREEN_BOLD'},
                {'label': 'Filtered Tables', 'value': str(len(filtered_tables)), 'color': 'YELLOW_BOLD'},
                {'label': 'Shards per Table', 'value': str(args.table_count), 'color': 'CYAN_BOLD'},
                {'label': 'Total Shards', 'value': str(total_shards), 'color': 'MAGENTA_BOLD'}
            ],
            'options': [
                {'name': 'Reset numbering per DB', 'enabled': args.reset_per_db},
                {'name': 'Zero padding', 'enabled': args.pad_zero},
                {'name': 'Table filtering', 'enabled': selected_tables is not None}
            ]
        }

        # Add selected tables info if filtering is enabled
        if selected_tables:
            config_summary['table_stats'].append({
                'label': 'Selected Tables',
                'value': ', '.join(selected_tables),
                'color': 'BLUE_BOLD'
            })

        ColorFormatter.print_config_summary(config_summary)

        # Generate sharded SQL
        sharded_sql = generator.generate_sharded_sql(filtered_tables, db_name_prefix)

        # Check if output file exists and handle overwrite logic
        if check_output_file_exists(output_file) and not args.force:
            if not prompt_overwrite(output_file):
                ColorFormatter.print_info("Operation cancelled by user")
                sys.exit(0)

        # Write output file
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(sharded_sql)
            file_size = output_file.stat().st_size if output_file.exists() else 0
            size_str = f"{file_size:,} bytes" if file_size > 1024 else f"{file_size} bytes"
            print(f"Generated {str(output_file)} ({size_str})")
        except Exception as e:
            raise Exception(f"Error writing output file: {e}")

        ColorFormatter.print_success(f"Sharding completed: {str(output_file)}")

    except Exception as e:
        ColorFormatter.print_error(f"Execution failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()